% \iffalse meta-comment
%
% Copyright (C) 2010 by Jason Gross (JasonGross9+locality@gmail.com)
%
% This file may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either
% version 1.3c of this license or (at your option) any later
% version. The latest version of this license is in:
%
%   http://www.latex-project.org/lppl.txt
%
% and version 1.3c or later is part of all distributions of
% LaTeX version 2005/12/01 or later.
%
% \fi
%
%
% \iffalse
%<package>\NeedsTeXFormat{LaTeX2e}[1999/12/01]
%<package>\ProvidesPackage{locality}
%<package> [2010/11/11 v0.3 Various macros for keeping things local]
%<package>\RequirePackage{etoolbox}[2009/08/06]
%<package>\RequirePackage{etex}[1998/03/26]
%
%<*driver>
\documentclass{ltxdoc}
\usepackage{locality}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
  \DocInput{locality.dtx}
\end{document}
%</driver>
% \fi
%
% \CheckSum{0}
%
% \CharacterTable
% {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%  Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%  Digits        \0\1\2\3\4\5\6\7\8\9
%  Exclamation   \!     Double quote  \"     Hash (number) \#
%  Dollar        \$     Percent       \%     Ampersand     \&
%  Acute accent  \'     Left paren    \(     Right paren   \)
%  Asterisk      \*     Plus          \+     Comma         \,
%  Minus         \-     Point         \.     Solidus       \/
%  Colon         \:     Semicolon     \;     Less than     \<
%  Equals        \=     Greater than  \>     Question mark \?
%  Commercial at \@     Left bracket  \[     Backslash     \\
%  Right bracket \]     Circumflex    \^     Underscore    \_
%  Grave accent  \`     Left brace    \{     Vertical bar  \|
%  Right brace   \}     Tilde         \~}
%
% \changes{v0.1}{2010/06/15}{Initial version.  Please note that some macros
%                            have not yet been tested.}
% \changes{v0.2}{2010/11/11}{Switched the order of tests in \string
%           \manyaftergroup, eliminating an infinite loop.  Added \string
%           \DeclareNonlocal*s\space, \string\pushvalues, \string\popvalues,
%           \string\pushvalue, \string\popvalue, and a few others. Fixed 
%           \string\DeclareNonlocal*\space to work with \string\aftergroup.
%           Added requirement for etoolbox, so that patching takes place at
%           the end of the preamble.}
% \changes{v0.3}{2010/12/15}{Fixed some bugs with \string\@for.  Made all commands
%           accepting argument lists require comma delimited lists.  Added
%           commands to make registers local.  Added local and nonlocal
%           commands for chars.  Made \string\savevalue and \string\restorevalue
%           do the right thing with registers.  Added requirement for etex-pkg.
%           XXX TODO: Add documentation for
%           new commands, test them, fix some spelling.  Give \string\makecommandslocal
%           a saner name and deprecate the old one.  Deprecate \string\manyaftergroup.
%           Update changes.txt.  Make unit tests.}
%
% \GetFileInfo{locality.sty}
%
% \DoNotIndex{\#,\$,\%,\&,\@,\\,\{,\},\^,\_,\~,\ }
% \DoNotIndex{}
%
% \title{The \textsf{locality} package\thanks{This document
%   corresponds to \textsf{locality}~\fileversion,
%   dated~\filedate.}}
% \author{Jason Gross \\ \texttt{JasonGross9+locality@gmail.com}}
%
% \maketitle
%
% \section{Introduction}
% 
% The \textsf{locality} package provides various macros to keep changes local
% to the current group.  This allows one to (re)define helper macros
% without worrying about accidentally changing the functionality of another
% package's or the user's definitions.  Additionally, it allows recursive
% macros to have some definitions persist between calls, and others be local.
%
% \section{Usage}
% I give the usage and specification of every macro defined.  I give bugs when
% I know them (please email me if you find other bugs, or have fixes for the
% bugs I list).  I sometimes give extra description or justification.
%
% \DescribeMacro{\manyaftergroup}
% \noindent Usage: |\manyaftergroup|\marg{tokens} \par\noindent
% Specification: The \meta{tokens} get placed after the current group \par\noindent
% Bugs: No braces are permitted, spaces are stripped
%
% I've often wanted to use \TeX's |\aftergroup| with a variable-length
% argument. This macro allows this.  It is expandable (may be used in
% |\edef|), but it gobbles spaces.
%
% ToDo: Write a version of this macro that preserves spaces, allows braces.
%
% \DescribeMacro{\locallydefine}
% \noindent Usage: |\locallydefine|\marg{macro}\marg{processing} \par\noindent
% Specification: Execute \meta{processing} inside of a group, and make
% the definition of |\macro| persist after the group ends. \par\noindent
% Bugs: Changes via |\let| to an unexpandable macro yield an infinite recursive
% loop.
%
% Normally, when you define a macro in a group, it's definition reverts after
% the group ends, unless you use |\global|.  If you use |\global|, then the
% new definition replaces the current definition on all levels.  This macro
% provides something in between.
%
% \DescribeMacro{\DeclareNonlocalMacro}
% \noindent Usage: |\DeclareNonlocalMacro|\marg{macro} \par\noindent
% Specification: Any changes to the definition of |\macro| persist
% after the end of the current group. \par\noindent
% Bugs: Changes via |\let| to an unexpandable macro yield an infinite recursive
% loop.  Only works with |\begingroup| |\endgroup| (not with braces).
%
% This macro generalized |\locallydefine|.
%
%
% \DescribeMacro{\DeclareNonlocalMacros}
% \noindent Usage: |\DeclareNonlocalMacros|\marg{macro list} \par\noindent
% \noindent Example: |\DeclareNonlocalMacros{\macroi,\macroii}| \par\noindent
% Specification: \marg{macro list} Should be a comma-separated list of macros.
% This command will run |\DeclareNonlocalMacro| on each argument.
%
%
% \DescribeMacro{\DeclareNonlocalTheRegister}\DescribeMacro{\DeclareNonlocalCount}
% \DescribeMacro{\DeclareNonlocalDimen}\DescribeMacro{\DeclareNonlocalSkip}
% \DescribeMacro{\DeclareNonlocalMuskip}\DescribeMacro{\DeclareNonlocalToks}
% \noindent Usage: |\DeclareNonlocalCount|\marg{count} \par\noindent
% \phantom{Usage:} |\DeclareNonlocalDimen|\marg{dimen} \par\noindent
% \phantom{Usage:} |\DeclareNonlocalSkip|\marg{skip} \par\noindent
% \phantom{Usage:} |\DeclareNonlocalMuskip|\marg{muskip} \par\noindent
% \phantom{Usage:} |\DeclareNonlocalToks|\marg{toks} \par\noindent
% Specification: Any changes to the value in \meta{register} persist
% after the end of the current group. \par\noindent
%
% Registers for \meta{count}s, \meta{dimen}s, \meta{skip}s, and \meta{muskips}s
% can all be made nonlocal with |\DeclareNonlocalTheRegister|.
%
% Bugs: Only works with |\begingroup| |\endgroup| (not with braces).  Only
%  works if the argument is a single token.
%
% These do the same thing to registers (\meta{count}s, \meta{length}s, and 
% \meta{tok}s) that |\DeclareNonlocalMacro| does to macros.
%
%
% \DescribeMacro{\DeclareNonlocalTheRegister}\DescribeMacro{\DeclareNonlocalCount}
% \DescribeMacro{\DeclareNonlocalDimen}\DescribeMacro{\DeclareNonlocalSkip}
% \DescribeMacro{\DeclareNonlocalMuskip}\DescribeMacro{\DeclareNonlocalToks}
% \noindent Usage: |\DeclareNonlocalCounts|\marg{list of counts (comma separated)} \par\noindent
% \phantom{Usage:} |\DeclareNonlocalDimens|\marg{list of dimens (comma separated)} \par\noindent
% \phantom{Usage:} |\DeclareNonlocalSkips|\marg{list of skips (comma separated)} \par\noindent
% \phantom{Usage:} |\DeclareNonlocalMuskips|\marg{list of muskips} \par\noindent
% \phantom{Usage:} |\DeclareNonlocalTokses|\marg{list of toks (comma separated)} \par\noindent
% Specification: Any changes to the value in \meta{register}s persist
% after the end of the current group. \par\noindent
%
% \DescribeMacro{\pushvalue}\DescribeMacro{\popvalue}\noindent 
% Usage: |\pushvalue|\marg{macro} \par\noindent
% \phantom{Usage:} |\popvalue|\marg{macro} \par
% \noindent Specification: The argument \marg{macro} is backed up by
%  |\pushvalue|, and the most recently backed up value is restored by
%  |\popvalue|.  The macro definitions are saved using a stack.
%
%
% \DescribeMacro{\savevalues}\DescribeMacro{\restorevalues}
% \noindent Usage: |\savevalues|\marg{list of macros (no separator)} \par\noindent
% \phantom{Usage:} |\restorevalues|\marg{list of macros (no separator)} \par\noindent
% Specification: Every token in the passed argument is backed up by
%  |\savevalues|, and the most recently backed up values are restored by
%  |\restorevalues|.
%
%
% \DescribeMacro{\pushvalues}\DescribeMacro{\popvalues}\noindent 
% Usage: |\pushvalues|\marg{list of macros (comma separated)} \par\noindent
% \phantom{Usage:} |\popvalues|\marg{list of macros (comma separated)} \par
%  \noindent Specification: Every macro in the passed argument is backed up by
%  |\pushvalues|, and the most recently backed up values are restored by
%  |\popvalues|.  The macro definitions are saved using a stack.
%
%
% \DescribeMacro{\makecommandslocal}
% \noindent Usage: |\makecommandslocal|\marg{list of macros (no separator)}\marg{code} \par\noindent
% Specification: Every token in the first argument is made local to \meta{code};
%  changes made to their definitions do not persist outside of \meta{code}.
%
% This macro is the natural opposite of |\DeclareNonlocalMacro|; it allows 
% some macros to behave as if \meta{code} was inside a group, while the rest
% of the macros behave as if they were not.
%
%
% \DescribeMacro{\ignoreglobal}\DescribeMacro{\obeyglobal}\DescribeMacro{\unignoreglobal}
% \noindent Usage: |\ignoreglobal| \par\noindent
% \noindent Usage: |\unignoreglobal| \par\noindent
% \noindent Usage: |\obeyglobal| \par\noindent
% Specification: The macro |\ignoreglobal| causes global changes, such as
% |\edef|, |\xdef|, and those prefaced by |\global|, to be local.  The macro 
% |\obeyglobal| causes these to be treated as global.  The macro 
% |\unignoreglobal| undoes the changes made by the last |\ignoreglobal|.  If
% you call |\ignoreglobal| twice, then you must call |\unignoreglobal| twice to
% allow global changes.
%
% \DescribeMacro{\makecounterslocal}
% \noindent Usage: |\makecounterslocal| \par\noindent
% Specification: The macro |\makecounterslocal| redefines the \LaTeX{} 
% \meta{counter} macros so that their changes are local, instead of global.
% At the end of the group in which |\makecounterslocal| is called, 
% \meta{counter} macros revert to being global.
%
% \StopEventually{\PrintChanges\PrintIndex}
%
% \section{Implementation}
% \subsection{Helper functions}
% The following definitions are preliminary, to allow various tricks with |\def|.
%    \begin{macrocode}
\def\@nil{\PackageError{locality}%
  {Macro \string\@nil\space has been called.}
  {\string\@nil\space is meant to be an internal delimiter,
    and meant to never be expanded.  There's probably a bug
    in the package source code, somewhere.}}
\def\if@nil#1{\@if@nil#1\@@nil}
\def\@if@nil#1#2\@@nil{\ifx\@nil#1}
% We'll be messing with |\global|, so we better have a backup.
\let\locality@tex@global=\global
%    \end{macrocode}
%
% \begin{macro}{\locality@global@non@collision@unique@count}
% At various places, I want to have a macro associated with a certain name
% which hasn't been used before.  I use this count to number them.  I use
% a count, instead of a counter, so that I can control whether or not it's
% global.  The long name, with lots of |@|s, is to (hopefully) avoid 
% collisions.
%    \begin{macrocode}
\newcount\locality@global@non@collision@unique@count
\locality@global@non@collision@unique@count=0
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\locality@swaparg}
% Taken from etextools and texapi.  I've had compatibility problems
% with biblatex and etextools, and texapi breaks some of etoolbox
% Names are different to avoid collisions.
%    \begin{macrocode}
\newcommand{\locality@swaparg}[2]{#2{#1}}
\newcommand{\locality@swap}[2]{#2#1}
\newcommand{\locality@passexpanded}[2]{%
  \expandafter\locality@swaparg\expandafter{#2}{#1}%
}
%    \end{macrocode}
% \end{macro}

%
%
% \begin{macro}{\locality@parseargumentlist}
% This macro parses an argument list, applying a given macro
% to each element of the comma-separated list.
%    \begin{macrocode}
\newcommand{\locality@parseargumentlist}[2]{%
  \@for\locality@argument@name:=\noexpand#2\do{%
    \locality@passexpanded{#1}{\locality@argument@name}%
  }%
}
%    \end{macrocode}
% \end{macro} 
%
% \begin{macro}{\manyaftergroup}
%
% The macro |\manyaftergroup| works by parsing it's argument one token at a
% time, and applying |\aftergroup| to each argument.  It checks for the end
% with |\@nil|.
%    \begin{macrocode}
\long\def\@manyaftergroup#1{\if@nil#1 \else \aftergroup#1 
\expandafter\@manyaftergroup\fi}
\newcommand{\manyaftergroup}[1]{\@manyaftergroup#1\@nil}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\locallydefine}
% Execute the second argument passed locally, and then preserve the definition
% of the first argument passed.
%    \begin{macrocode}
\newcommand{\locallydefine}[2]{{#2\expandafter}%
  \expandafter\def\expandafter#1\expandafter{#1}}
%    \end{macrocode}
%
% \end{macro}
%
% The |\DeclareNonlocal| macros do some fancy stuff with |\begingroup| and
% |\endgroup|, so the old definitions must be saved.
%    \begin{macrocode}
\let\locality@tex@begingroup=\begingroup
\let\locality@tex@endgroup=\endgroup
%    \end{macrocode}
% These macros are extended versions of the |\locallydefine| macro; they 
% redefine |\endgroup| to preserve definitions after the current group ends.
% 
% Because |\aftergroup| would occur before definition restoration, we patch
% |\aftergroup| so that it instead appends tokens to the end of |\endgroup|.
% This doesn't fix all use cases, but it should fix a problem with the calc
% package.
%    \begin{macrocode}
\newcount\locality@global@aftergroup@count
\locality@global@aftergroup@count=-1
\newcommand\locality@patch@aftergroup{%
  \def\aftergroup{%
    \locality@tex@global\advance\locality@global@aftergroup@count by 1
    \afterassignment\locality@aftergroup\locality@tex@global
    \expandafter\let\csname locality@nextchar\space\the
      \locality@global@aftergroup@count\endcsname=%
  }%
}
\newcommand\locality@aftergroup{%
  \expandafter\expandafter\expandafter\def
  \expandafter\expandafter\expandafter\endgroup
  \expandafter\expandafter\expandafter{\expandafter\endgroup
    \csname locality@nextchar\space\the\locality@global@aftergroup@count
    \endcsname}%
}
%    \end{macrocode}
%
%
% \begin{macro}{\locality@DeclareNonlocalThing}
% This macro redefines |\endgroup| to do this for macro passed to it.
%
% First, back up |\endgroup| to a new macro.
%    \begin{macrocode}
\newcommand{\locality@DeclareNonlocalThing}[1]{%
  \locality@patch@groups % make sure that |\begingroup| and |\aftergroup| 
    % are patched.
  \locality@patch@aftergroup % first, patch |\aftergroup|
  \cslet{endgroup \the\locality@local@group@non@local@macro@count}{\endgroup}%
%    \end{macrocode}
% Redefine |\endgroup| to, in order: revert it's definition, insert code to 
% update the definition of the passed macro outside of the group, and call 
% the (reverted) version of |\endgroup|.
%    \begin{macrocode}
  \locality@passexpanded{\def\endgroup}{%
    \expandafter\expandafter\expandafter\let\expandafter
      \expandafter\expandafter\endgroup\expandafter\expandafter
      \csname endgroup \the\locality@local@group@non@local@macro@count
        \endcsname\expandafter\endgroup
    #1}%
  \advance\locality@local@group@non@local@macro@count by 1
}%
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\DeclareNonlocalMacro}
% \begin{macro}{\DeclareNonlocalTheRegister}
% \begin{macro}{\DeclareNonlocalCount}
% \begin{macro}{\DeclareNonlocalDimen}
% \begin{macro}{\DeclareNonlocalSkip}
% \begin{macro}{\DeclareNonlocalMuskip}
% \begin{macro}{\DeclareNonlocalMathChar}
% \begin{macro}{\DeclareNonlocalChar}
% \begin{macro}{\DeclareNonlocalToks}
%    \begin{macrocode}
\newcommand{\DeclareNonlocalMacro}[1]{%
  \locality@DeclareNonlocalThing{\expandafter\def\expandafter#1\expandafter{#1}}%
}%
\newcommand{\DeclareNonlocalTheRegister}[1]{%
  \locality@DeclareNonlocalThing{\expandafter#1\expandafter=\the#1 }% Note the space.  This is to 
% prevent something like 
% |\newcount\tempc\begingroup \DeclareNonlocalCount\tempc \tempc=1\endgroup1|
% from setting |\tempc| to 11.
}
\let\DeclareNonlocalCount=\DeclareNonlocalTheRegister
\let\DeclareNonlocalDimen=\DeclareNonlocalTheRegister
\let\DeclareNonlocalSkip=\DeclareNonlocalTheRegister
\let\DeclareNonlocalMuskip=\DeclareNonlocalTheRegister
\newcommand{\DeclareNonlocalChar}[1]{%
  \locality@DeclareNonlocalThing{\expandafter\chardef\expandafter#1\expandafter=#1}%
}
\newcommand{\DeclareNonlocalMathChar}[1]{%
  \locality@DeclareNonlocalThing{\expandafter\mathchardef\expandafter#1\expandafter=#1}%
}
\newcommand{\DeclareNonlocalToks}[1]{%
  \locality@DeclareNonlocalThing{\expandafter#1\expandafter=\expandafter{\the#1}}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\DeclareNonlocalMacros}
% \begin{macro}{\DeclareNonlocalTheRegisters}
% \begin{macro}{\DeclareNonlocalCounts}
% \begin{macro}{\DeclareNonlocalDimens}
% \begin{macro}{\DeclareNonlocalSkips}
% \begin{macro}{\DeclareNonlocalMuskips}
% \begin{macro}{\DeclareNonlocalChars}
% \begin{macro}{\DeclareNonlocalMathChars}
% \begin{macro}{\DeclareNonlocalTokses}
%    \begin{macrocode}
\newcommand{\DeclareNonlocalMacros}[1]{\locality@parseargumentlist{\DeclareNonlocalMacro}{#1}}
\newcommand{\DeclareNonlocalTheRegisters}[1]{\locality@parseargumentlist{\DeclareNonlocalTheRegister}{#1}}
\let\DeclareNonlocalCounts=\DeclareNonlocalTheRegisters
\let\DeclareNonlocalDimens=\DeclareNonlocalTheRegisters
\let\DeclareNonlocalSkips=\DeclareNonlocalTheRegisters
\let\DeclareNonlocalMuskips=\DeclareNonlocalTheRegisters
\newcommand{\DeclareNonlocalChars}[1]{\locality@parseargumentlist{\DeclareNonlocalChar}{#1}}
\newcommand{\DeclareNonlocalMathChars}[1]{\locality@parseargumentlist{\DeclareNonlocalMathChar}{#1}}
\newcommand{\DeclareNonlocalTokses}[1]{\locality@parseargumentlist{\DeclareNonlocalToks}{#1}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% I redefine |\begingroup| to reset the locality macros, so nesting works.
% Patching only occurs when you need non-local things, so that we don't make
% groups that don't take advantage of this stop working.
%
% TODO: Decide whether or not it's worth it to unpatch grouping in subgroups.
%       It'll make it less likely that we make mistakes, but more likely to
%       eat up time if we're nesting groups.  It's probably worth it.
%    \begin{macrocode}
\newcount\locality@local@group@non@local@macro@count % Hopefully, this
% won't collide with anything.  I hope putting this out here allows
% proper nesting of groups
\newcommand\locality@patch@groups{%
  \def\begingroup{\locality@tex@begingroup
    \def\endgroup{\locality@tex@endgroup}% not \let, because
                       % that would break my |\aftergroup| patch
    \locality@local@group@non@local@macro@count=0
  }%
  \def\endgroup{\locality@tex@endgroup}% not \let, because
                       % that would break my |\aftergroup| patch
  \locality@local@group@non@local@macro@count=0
  \let\locality@patch@groups\relax
}
%    \end{macrocode}
%
%
%
%
%
% \begin{macro}{\locality@branchbymeaningtype}
% Branches based on whether its meaning is |\char|, |\count|,
% |\dimen|, |\mathchar|, |\muskip|, |\skip|, |\toks|, expandable macro, or
% something else.
%    \begin{macrocode}
\long\def\locality@ifempty#1\then#2#3{\ifstrempty{#1}{#2}{#1}}
\long\def\locality@ifone#1#2\then#3#4{\ifstrempty{#2}{#3}{#4}}
\long\def\locality@iftwo#1#2#3\then#4#5{\ifstrempty{#3}{#4}{#5}}
\expandafter\locality@swap\expandafter{\meaning\char"}{\long\def\@locality@ifchar#1}#2\then#3#4{%
  \ifstrempty{#1}{\ifstrempty{#2}{#4}{\locality@ifone{#2}{#4}{\locality@iftwo{#4}{#3}}}}{#4}%
}
\expandafter\locality@swap\expandafter{\meaning\count}{\long\def\@locality@ifcount#1}#2\then#3#4{%
  \ifstrempty{#1}{\ifstrempty{#2}{#4}{\locality@ifone{#2}{#4}{#3}}}{#4}%
}
\expandafter\locality@swap\expandafter{\meaning\dimen}{\long\def\@locality@ifdimen#1}#2\then#3#4{%
  \ifstrempty{#1}{\ifstrempty{#2}{#4}{\locality@ifone{#2}{#4}{#3}}}{#4}%
}
\expandafter\locality@swap\expandafter{\meaning\mathchar}{\long\def\@locality@ifmathchar#1}#2\then#3#4{%
  \ifstrempty{#1}{\ifstrempty{#2}{#4}{\locality@ifone{#2}{#4}{#3}}}{#4}%
}
\expandafter\locality@swap\expandafter{\meaning\muskip}{\long\def\@locality@ifmuskip#1}#2\then#3#4{%
  \ifstrempty{#1}{\ifstrempty{#2}{#4}{\locality@ifone{#2}{#4}{#3}}}{#4}%
}
\expandafter\locality@swap\expandafter{\meaning\skip}{\long\def\@locality@ifskip#1}#2\then#3#4{%
  \ifstrempty{#1}{\ifstrempty{#2}{#4}{\locality@ifone{#2}{#4}{#3}}}{#4}%
}
\expandafter\locality@swap\expandafter{\meaning\toks}{\long\def\@locality@iftoks#1}#2\then#3#4{%
  \ifstrempty{#1}{\ifstrempty{#2}{#4}{\locality@ifone{#2}{#4}{#3}}}{#4}%
}
\expandafter\locality@swap\expandafter{\meaning\@empty}{\long\def\@locality@ifmacro#1}#2\then#3#4{%
  \ifstrempty{#1}{#3}{#4}%
}
  

\locality@passexpanded{\locality@passexpanded{\long\def\locality@ifchar#1#2#3}}{\expandafter\locality@swap\expandafter{\meaning\char"}{\expandafter\@locality@ifchar\meaning#1}\then{#2}{#3}}
\locality@passexpanded{\locality@passexpanded{\long\def\locality@ifcount#1#2#3}}{\expandafter\locality@swap\expandafter{\meaning\count}{\expandafter\@locality@ifcount\meaning#1}\then{#2}{#3}}
\locality@passexpanded{\locality@passexpanded{\long\def\locality@ifdimen#1#2#3}}{\expandafter\locality@swap\expandafter{\meaning\dimen}{\expandafter\@locality@ifdimen\meaning#1}\then{#2}{#3}}
\locality@passexpanded{\locality@passexpanded{\long\def\locality@ifmathchar#1#2#3}}{\expandafter\locality@swap\expandafter{\meaning\mathchar}{\expandafter\@locality@ifmathchar\meaning#1}\then{#2}{#3}}
\locality@passexpanded{\locality@passexpanded{\long\def\locality@ifmuskip#1#2#3}}{\expandafter\locality@swap\expandafter{\meaning\muskip}{\expandafter\@locality@ifmuskip\meaning#1}\then{#2}{#3}}
\locality@passexpanded{\locality@passexpanded{\long\def\locality@ifskip#1#2#3}}{\expandafter\locality@swap\expandafter{\meaning\skip}{\expandafter\@locality@ifskip\meaning#1}\then{#2}{#3}}
\locality@passexpanded{\locality@passexpanded{\long\def\locality@iftoks#1#2#3}}{\expandafter\locality@swap\expandafter{\meaning\toks}{\expandafter\@locality@iftoks\meaning#1}\then{#2}{#3}}
\locality@passexpanded{\locality@passexpanded{\long\def\locality@ifmacro#1#2#3}}{\expandafter\locality@swap\expandafter{\meaning\@empty}{\expandafter\@locality@ifmacro\meaning#1}\then{#2}{#3}}

\newcommand{\locality@branchbymeaningtype}[9]{%
  \locality@ifchar{#1}{#2}{%
  \locality@ifcount{#1}{#3}{%
  \locality@ifdimen{#1}{#4}{%
  \locality@ifmathchar{#1}{#5}{%
  \locality@ifmuskip{#1}{#6}{%
  \locality@ifskip{#1}{#7}{%
  \locality@iftoks{#1}{#8}{%
  \locality@ifmacro{#1}{#9}{%
  \expandafter\@firstofone\@gobble% If it's something else, then don't gobble at the end of the macro; the tenth parameter comes after
  }}}}}}}}\@gobble
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
% \begin{macro}{\locality@savething}
% \begin{macro}{\locality@restorething}
% Called as |\locality@savething[prefix]{\new}{\set}{\onbackupdefined}{\thing}|
%    \begin{macrocode}
\newcommand{\locality@savething}[5][locality backup ]{%
  \ifcsundef{#1\string#5}{%
    \expandafter\locality@swap\expandafter{\csname #1\string#5\endcsname}{#2}%
  }{%
    \locality@passexpanded{#4}{\csname #1\string#5\endcsname}%
  }%
  \expandafter\locality@swap\expandafter{\csname #1\string#5\endcsname}{#3}=#5%
}

% Called as |\locality@restorething[prefix]{\set}{\recurse}{\thing}|
\newcommand{\locality@restorething}[4][locality backup ]{%
  \ifcsundef{#1\string#4}{%
    \undef#4%
  }{%
    \expandafter\locality@swap\expandafter{\csname #1\string#4\endcsname}{#2#4=}%
    \passexpanded{#3}{\csname #1\string#4\endcsname}%
  }%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\savemacro}
% \begin{macro}{\savechar}
% \begin{macro}{\savecount}
% \begin{macro}{\savedimen}
% \begin{macro}{\savemathchar}
% \begin{macro}{\savemuskip}
% \begin{macro}{\saveskip}
% \begin{macro}{\savetoks}
% \begin{macro}{\savemacros}
% \begin{macro}{\savechars}
% \begin{macro}{\savecounts}
% \begin{macro}{\savedimens}
% \begin{macro}{\savemathchars}
% \begin{macro}{\savemuskips}
% \begin{macro}{\saveskips}
% \begin{macro}{\savetokses}
%    \begin{macrocode}
\def\locality@newchar#1{\chardef#1=0\relax}
\def\locality@newmathchar#1{\mathchardef#1=0\relax}
\newcommand{\savemacro}[2][locality backup ]{\locality@savething[#1]{\@gobble}{\let}{\@gobble}{#2}}
\newcommand{\savechar}[2][locality backup ]{\locality@savething[#1]{\locality@newchar}{\chardef}{\@gobble}{#2}}
\newcommand{\savecount}[2][locality backup ]{\locality@savething[#1]{\loccount}{\@empty}{\@gobble}{#2}}
\newcommand{\savedimen}[2][locality backup ]{\locality@savething[#1]{\locdimen}{\@empty}{\@gobble}{#2}}
\newcommand{\savemathchar}[2][locality backup ]{\locality@savething[#1]{\locality@newmathchar}{\mathchardef}{\@gobble}{#2}}
\newcommand{\savemuskip}[2][locality backup ]{\locality@savething[#1]{\locmuskip}{\@empty}{\@gobble}{#2}}
\newcommand{\saveskip}[2][locality backup ]{\locality@savething[#1]{\locskip}{\@empty}{\@gobble}{#2}}
\newcommand{\savetoks}[2][locality backup ]{\locality@savething[#1]{\loctoks}{\@empty}{\@gobble}{#2}}

\newcommand{\savemacros}[2][locality backup ]{\locality@parseargumentlist{\savemacro[#1]}{#2}}
\newcommand{\savechars}[2][locality backup ]{\locality@parseargumentlist{\savechar[#1]}{#2}}
\newcommand{\savecounts}[2][locality backup ]{\locality@parseargumentlist{\savecount[#1]}{#2}}
\newcommand{\savedimens}[2][locality backup ]{\locality@parseargumentlist{\savedimen[#1]}{#2}}
\newcommand{\savemathchars}[2][locality backup ]{\locality@parseargumentlist{\savemathchar[#1]}{#2}}
\newcommand{\savemuskips}[2][locality backup ]{\locality@parseargumentlist{\savemuskip[#1]}{#2}}
\newcommand{\saveskips}[2][locality backup ]{\locality@parseargumentlist{\saveskip[#1]}{#2}}
\newcommand{\savetokses}[2][locality backup ]{\locality@parseargumentlist{\savetoks[#1]}{#2}}%
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
% \begin{macro}{\restoremacro}
% \begin{macro}{\restorechar}
% \begin{macro}{\restorecount}
% \begin{macro}{\restoredimen}
% \begin{macro}{\restoremathchar}
% \begin{macro}{\restoremuskip}
% \begin{macro}{\restoreskip}
% \begin{macro}{\restoretoks}
% \begin{macro}{\restoremacros}
% \begin{macro}{\restorechars}
% \begin{macro}{\restorecounts}
% \begin{macro}{\restoredimens}
% \begin{macro}{\restoremathchars}
% \begin{macro}{\restoremuskips}
% \begin{macro}{\restoreskips}
% \begin{macro}{\restoretokses}
%    \begin{macrocode}
\newcommand{\restoremacro}[2][locality backup ]{\locality@restorething[#1]{\let}{\@gobble}{#2}}
\newcommand{\restorechar}[2][locality backup ]{\locality@restorething[#1]{\chardef}{\@gobble}{#2}}
\newcommand{\restorecount}[2][locality backup ]{\locality@restorething[#1]{\@empty}{\@gobble}{#2}}
\newcommand{\restoredimen}[2][locality backup ]{\locality@restorething[#1]{\@empty}{\@gobble}{#2}}
\newcommand{\restoremathchar}[2][locality backup ]{\locality@restorething[#1]{\mathchardef}{\@gobble}{#2}}
\newcommand{\restoremuskip}[2][locality backup ]{\locality@restorething[#1]{\@empty}{\@gobble}{#2}}
\newcommand{\restoreskip}[2][locality backup ]{\locality@restorething[#1]{\@empty}{\@gobble}{#2}}
\newcommand{\restoretoks}[2][locality backup ]{\locality@restorething[#1]{\@empty}{\@gobble}{#2}}

\newcommand{\restoremacros}[2][locality backup ]{\locality@parseargumentlist{\restoremacro[#1]}{#2}}
\newcommand{\restorechars}[2][locality backup ]{\locality@parseargumentlist{\restorechar[#1]}{#2}}
\newcommand{\restorecounts}[2][locality backup ]{\locality@parseargumentlist{\restorecount[#1]}{#2}}
\newcommand{\restoredimens}[2][locality backup ]{\locality@parseargumentlist{\restoredimen[#1]}{#2}}
\newcommand{\restoremathchars}[2][locality backup ]{\locality@parseargumentlist{\restoremathchar[#1]}{#2}}
\newcommand{\restoremuskips}[2][locality backup ]{\locality@parseargumentlist{\restoremuskip[#1]}{#2}}
\newcommand{\restoreskips}[2][locality backup ]{\locality@parseargumentlist{\restoreskip[#1]}{#2}}
\newcommand{\restoretokses}[2][locality backup ]{\locality@parseargumentlist{\restoretoks[#1]}{#2}}%
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\locality@pushthing}
% \begin{macro}{\locality@popthing}
%    \begin{macrocode}
\newcommand{\locality@pushthing}[4][locality backup ]{\locality@savething[#1]{#2}{#3}{\locality@pushthing[#1]{#2}{#3}}{#4}}

\newcommand{\locality@popthing}[3][locality backup ]{\locality@restorething[#1]{#2}{\locality@popthing[#1]{#2}}{#3}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\pushmacro}
% \begin{macro}{\pushchar}
% \begin{macro}{\pushcount}
% \begin{macro}{\pushdimen}
% \begin{macro}{\pushmathchar}
% \begin{macro}{\pushmuskip}
% \begin{macro}{\pushskip}
% \begin{macro}{\pushtoks}
% \begin{macro}{\pushmacros}
% \begin{macro}{\pushchars}
% \begin{macro}{\pushcounts}
% \begin{macro}{\pushdimens}
% \begin{macro}{\pushmathchars}
% \begin{macro}{\pushmuskips}
% \begin{macro}{\pushskips}
% \begin{macro}{\pushtokses}
%    \begin{macrocode}
\newcommand{\pushmacro}[2][locality backup ]{\locality@pushthing[#1]{\@gobble}{\let}{#2}}
\newcommand{\pushchar}[2][locality backup ]{\locality@pushthing[#1]{\locality@newchar}{\chardef}}
\newcommand{\pushcount}[2][locality backup ]{\locality@pushthing[#1]{\newcount}{\@empty}{#2}}
\newcommand{\pushdimen}[2][locality backup ]{\locality@pushthing[#1]{\newdimen}{\@empty}{#2}}
\newcommand{\pushmathchar}[2][locality backup ]{\locality@pushthing[#1]{\locality@newmathchar}{\mathchardef}{#2}}
\newcommand{\pushmuskip}[2][locality backup ]{\locality@pushthing[#1]{\newmuskip}{\@empty}{#2}}
\newcommand{\pushskip}[2][locality backup ]{\locality@pushthing[#1]{\newskip}{\@empty}{#2}}
\newcommand{\pushtoks}[2][locality backup ]{\locality@pushthing[#1]{\newtoks}{\@empty}{#2}}

\newcommand{\pushmacros}[2][locality backup ]{\locality@parseargumentlist{\pushmacro[#1]}{#2}}
\newcommand{\pushchars}[2][locality backup ]{\locality@parseargumentlist{\pushchar[#1]}{#2}}
\newcommand{\pushcounts}[2][locality backup ]{\locality@parseargumentlist{\pushcount[#1]}{#2}}
\newcommand{\pushdimens}[2][locality backup ]{\locality@parseargumentlist{\pushdimen[#1]}{#2}}
\newcommand{\pushmathchars}[2][locality backup ]{\locality@parseargumentlist{\pushmathchar[#1]}{#2}}
\newcommand{\pushmuskips}[2][locality backup ]{\locality@parseargumentlist{\pushmuskip[#1]}{#2}}
\newcommand{\pushskips}[2][locality backup ]{\locality@parseargumentlist{\pushskip[#1]}{#2}}
\newcommand{\pushtokses}[2][locality backup ]{\locality@parseargumentlist{\pushtoks[#1]}{#2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\popmacro}
% \begin{macro}{\popchar}
% \begin{macro}{\popcount}
% \begin{macro}{\popdimen}
% \begin{macro}{\popmathchar}
% \begin{macro}{\popmuskip}
% \begin{macro}{\popskip}
% \begin{macro}{\poptoks}
% \begin{macro}{\popmacros}
% \begin{macro}{\popchars}
% \begin{macro}{\popcounts}
% \begin{macro}{\popdimens}
% \begin{macro}{\popmathchars}
% \begin{macro}{\popmuskips}
% \begin{macro}{\popskips}
% \begin{macro}{\poptokses}
%    \begin{macrocode}
\newcommand{\popmacro}[2][locality backup ]{\locality@popthing[#1]{\let}{#2}}
\newcommand{\popchar}[2][locality backup ]{\locality@popthing[#1]{\chardef}}
\newcommand{\popcount}[2][locality backup ]{\locality@popthing[#1]{\@empty}{#2}}
\newcommand{\popdimen}[2][locality backup ]{\locality@popthing[#1]{\@empty}{#2}}
\newcommand{\popmathchar}[2][locality backup ]{\locality@popthing[#1]{\mathchardef}{#2}}
\newcommand{\popmuskip}[2][locality backup ]{\locality@popthing[#1]{\@empty}{#2}}
\newcommand{\popskip}[2][locality backup ]{\locality@popthing[#1]{\@empty}{#2}}
\newcommand{\poptoks}[2][locality backup ]{\locality@popthing[#1]{\@empty}{#2}}

\newcommand{\popmacros}[2][locality backup ]{\locality@parseargumentlist{\popmacro[#1]}{#2}}
\newcommand{\popchars}[2][locality backup ]{\locality@parseargumentlist{\popchar[#1]}{#2}}
\newcommand{\popcounts}[2][locality backup ]{\locality@parseargumentlist{\popcount[#1]}{#2}}
\newcommand{\popdimens}[2][locality backup ]{\locality@parseargumentlist{\popdimen[#1]}{#2}}
\newcommand{\popmathchars}[2][locality backup ]{\locality@parseargumentlist{\popmathchar[#1]}{#2}}
\newcommand{\popmuskips}[2][locality backup ]{\locality@parseargumentlist{\popmuskip[#1]}{#2}}
\newcommand{\popskips}[2][locality backup ]{\locality@parseargumentlist{\popskip[#1]}{#2}}
\newcommand{\poptokses}[2][locality backup ]{\locality@parseargumentlist{\poptoks[#1]}{#2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\pushvalue}
% \begin{macro}{\pushvalues}
% \begin{macro}{\popvalue}
% \begin{macro}{\popvalues}
% \begin{macro}{\savevalue}
% \begin{macro}{\savevalues}
% \begin{macro}{\restorevalue}
% \begin{macro}{\restorevalues}
%    \begin{macrocode}
\newcommand{\pushvalue}[2][locality backup ]{%
  \csname push\locality@branchbymeaningtype{#2}{char}{count}{dimen}{mathchar}{muskip}{skip}{toks}{macro}{macro}\endcsname
    [#1]{#2}%
}
\newcommand{\pushvalues}[2][locality backup ]{\locality@parseargumentlist{\pushvalue[#1]}{#2}}

\newcommand{\popvalue}[2][locality backup ]{%
  \csname pop\locality@branchbymeaningtype{#2}{char}{count}{dimen}{mathchar}{muskip}{skip}{toks}{macro}{macro}\endcsname
    [#1]{#2}%
}
\newcommand{\popvalues}[2][locality backup ]{\locality@parseargumentlist{\popvalue[#1]}{#2}}


\newcommand{\savevalue}[2][locality backup ]{%
  \csname save\locality@branchbymeaningtype{#2}{char}{count}{dimen}{mathchar}{muskip}{skip}{toks}{macro}{macro}\endcsname
    [#1]{#2}%
}
\newcommand{\savevalues}[2][locality backup ]{\locality@parseargumentlist{\savevalue[#1]}{#2}}

\newcommand{\restorevalue}[2][locality backup ]{%
  \csname restore\locality@branchbymeaningtype{#2}{char}{count}{dimen}{mathchar}{muskip}{skip}{toks}{macro}{macro}\endcsname
    [#1]{#2}%
} 
\newcommand{\restorevalues}[2][locality backup ]{\locality@parseargumentlist{\restorevalue[#1]}{#2}}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%
%
% \begin{macro}{\makecommandslocal}
% Save the macros, run the code, then restore the values.
%    \begin{macrocode}
\newcommand{\makecommandslocal}[3][\string\makecommandslocal backup]{\pushvalues[#1]{#2}#3\popvalues[#1]{#2}}
% I think the following breaks for special things like |\time|
\newcommand{\maketheregisterlocal}[2]{\expandafter\locality@swap\expandafter{\expandafter#1\expandafter=\the#1\relax}{#2}}
\newcommand{\maketoksregisterlocal}[2]{\expandafter\locality@swap\expandafter{\expandafter#1\expandafter=\expandafter{\the#1}\relax}{#2}}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\makecounterslocal}
% To make counters local without redefining them too badly (for example, this
% should work with the |calc| package, as long as you load |calc| first),
% we disable |\global|, and set |\gdef| and |\xdef| to |\def| and |\edef|
% respectively.
%
% \begin{macro}{\ignoreglobal}
% \begin{macro}{\obeyglobal}
% \begin{macro}{\unignoreglobal}
% We save the values of |\global|, |\gdef|, |\xdef|, globally, so
% that multiple calls don't fail.
%
% We also save the value of |\@cons|, a special macro used in counters, which
% uses |\xdef| to append something to a list.  Since it must be redefined for 
% counters, I'll redefine it here to do without |\xdef| fails.
%
% For reference, the original definition of |\@cons|, from |latex.ltx|, is \\
% |\def\@cons#1#2{\begingroup\let\@elt\relax\xdef#1{#1\@elt #2}\endgroup}|.
% I try to make this forward-compatible, but if the definition of |\@cons|
% changes too badly, this'll break.
%    \begin{macrocode}
\savevalues[locality globals global backup ]{\global,\gdef,\xdef,\@cons}
{\def\begingroup{\begingroup\DeclareNonlocalMacro{##1}}%
  \expandafter\expandafter\expandafter
}%
\locality@passexpanded{\locality@passexpanded{%
  \def\locality@cons#1#2}}{\@cons{#1}{#2}}
\newcommand{\obeyglobal}{\restorevalues[locality globals global backup ]{\global,\gdef,\xdef,\@cons}}
\newcommand{\unignoreglobal}{\popvalues[locality globals backup ]{\global,\gdef,\xdef,\@cons}}
\newcommand{\ignoreglobal}{%
  \pushvalues[locality globals backup ]{\global,\gdef,\xdef,\@cons}%
  \let\global=\relax \let\gdef=\def \let\xdef=\edef
  \let\@cons=\locality@cons
  \locality@passexpanded{\def\unignoreglobal}{\expandafter
    \def\expandafter\unignoreglobal\expandafter{\unignoreglobal}%
    \unignoreglobal}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% 
% Now, the actual macro.
%
% We redefine |\stepcounter|, |\addtocounter|, |\refstepcounter|, 
% |\setcounter|, |\@addtoreset|, and |\@definecounter|.
%
% Since |\newcounter| does everything with |\@addtoreset| and
% |\@definecounter|, it doesn't need and changes.
%    \begin{macrocode}
\newcommand{\makecounterslocal}{% FIX, to make more robust
  \expandafter\def\expandafter\stepcounter
    \expandafter##\expandafter1\expandafter{%
    \expandafter\ignoreglobal\stepcounter{##1}%
    \unignoreglobal
  }%
 %
  \expandafter\def\expandafter\refstepcounter
    \expandafter##\expandafter1\expandafter{%
    \expandafter\ignoreglobal\refstepcounter{##1}%
    \unignoreglobal
  }%
 %
  \expandafter\def\expandafter\setcounter
    \expandafter##\expandafter1%
    \expandafter##\expandafter2\expandafter{%
    \expandafter\ignoreglobal\setcounter{##1}{##2}%
    \unignoreglobal
  }%
 %
  \expandafter\def\expandafter\addtocounter
    \expandafter##\expandafter1%
    \expandafter##\expandafter2\expandafter{%
    \expandafter\ignoreglobal\addtocounter{##1}{##2}%
    \unignoreglobal
  }%
 %
  \expandafter\def\expandafter\@addtoreset
    \expandafter##\expandafter1%
    \expandafter##\expandafter2\expandafter{%
    \expandafter\ignoreglobal\@addtoreset{##1}{##2}%
    \unignoreglobal
  }%
 %
  \expandafter\def\expandafter\@definecounter
    \expandafter##\expandafter1\expandafter{%
    \expandafter\ignoreglobal\@definecounter{##1}%
    \unignoreglobal
  }%
  \locality@fix@for@amstext
  \locality@fix@for@calc
}
%    \end{macrocode}
%
% Following the example of the |calc| package, if the amstext package is loaded
% we must add the |\iffirstchoice@| switch as well. We patch the commands this 
% way since it's good practice when we know how many arguments they take.
%
% We use |\AtEndPreamble| to ensure that we catch the other package loads.
%    \begin{macrocode}
\AtEndPreamble{
  \@ifpackageloaded{amstext}{
    \newcommand{\locality@fix@for@amstext}{
      \expandafter\def\expandafter\stepcounter
        \expandafter##\expandafter1\expandafter{%
        \expandafter\iffirstchoice@\stepcounter{##1}\fi
      }
      \expandafter\def\expandafter\addtocounter
        \expandafter##\expandafter1%
        \expandafter##\expandafter2\expandafter{%
        \expandafter\iffirstchoice@\addtocounter{##1}{##2}\fi
      }
    }
  }{
    \let\locality@fix@for@amstext=\relax
  }
  \@ifpackageloaded{calc}{%
    \def\locality@fix@for@calc{\expandafter\def\expandafter\begingroup\expandafter{\begingroup\DeclareNonlocalTheRegister{\calc@A}}}
  }{
    \let\locality@fix@for@calc=\relax
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \Finale
\endinput
